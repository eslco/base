var c=class{constructor(e,t,s){this._times=new Map;this.name=e??"",this.debug=s?.debug??!1,e&&this.log(`${e} Start`),this.className=t??"",this.init()}static getInstance(e,t){let s=typeof $task<"u"?"QuanX":"Surge";return c.instances[s]||(c.instances[s]=c.classNames[s](e,s,t)),c.instances[s]}createProxy(e){return new Proxy(e,{get:this.getFn,set:this.setFn})}getFn(e,t,s){return e[t]}setFn(e,t,s,n){return e[t]=s,!0}getJSON(e,t={}){let s=this.getVal(e);return s?JSON.parse(s):t}setJSON(e,t){this.setVal(JSON.stringify(e),t)}msg(e=this.name,t="",s="",n){}log(e){this.debug&&(typeof e=="object"&&(e=JSON.stringify(e)),console.log(e))}timeStart(e){this._times.set(e,Date.now())}timeEnd(e){if(this._times?.has(e)){let t=Date.now()-this._times.get(e);this.log(`${e}: ${t}ms`),this._times.delete(e)}else this.log(`Timer with label ${e} does not exist.`)}exit(){$done({})}reject(){$done()}},a=c;a.instances={},a.classNames={QuanX:(e,t,s)=>new u(e,t,s),Surge:(e,t,s)=>new y(e,t,s)};var g=class extends a{getFn(e,t,s){let n=g.clientAdapter[t]||t;return super.getFn(e,n,s)}setFn(e,t,s,n){let r=g.clientAdapter[t]||t;return super.setFn(e,r,s,n)}init(){try{this.request=this.createProxy($request),this.response=this.createProxy($response)}catch(e){this.log(e.toString())}}getVal(e){return $persistentStore.read(e)}setVal(e,t){$persistentStore.write(e,t)}msg(e=this.name,t="",s="",n){$notification.post(e,t,s,{url:n??""})}async fetch(e){return await new Promise((t,s)=>{let{method:n,body:r,bodyBytes:i,...d}=e,f=i??r,l=f instanceof Uint8Array;$httpClient[n.toLowerCase()]({...d,body:f,"binary-mode":l},(p,h,b)=>{p&&s(p);let R=l?"bodyBytes":"body";t({status:h.status,headers:h.headers,[R]:b})})})}done(e){let t=e.response??e,s,n;t.bodyBytes?(s=t.bodyBytes,delete t.bodyBytes,n={...e},n.response?n.response.body=s:n.body=s):n=e,$done(n)}},y=g;y.clientAdapter={bodyBytes:"body"};var o=class extends a{static transferBodyBytes(e,t){return e instanceof ArrayBuffer?t==="Uint8Array"?new Uint8Array(e):e:e instanceof Uint8Array&&t==="ArrayBuffer"?e.buffer.slice(e.byteOffset,e.byteLength+e.byteOffset):e}init(){try{this.request=this.createProxy($request),this.response=this.createProxy($response)}catch(e){this.log(e.toString())}}getFn(e,t,s){let n=o.clientAdapter[t]||t,r=super.getFn(e,n,s);return t==="bodyBytes"&&(r=o.transferBodyBytes(r,"Uint8Array")),r}setFn(e,t,s,n){let r=o.clientAdapter[t]||t,i=s;return t==="bodyBytes"&&(i=o.transferBodyBytes(i,"Uint8Array")),super.setFn(e,r,i,n)}getVal(e){return $prefs.valueForKey(e)?.replace(/\0/g,"")}setVal(e,t){$prefs.setValueForKey(e,t)}msg(e=this.name,t="",s="",n){$notify(e,t,s,{"open-url":n??""})}async fetch(e){return await new Promise(t=>{let s={url:"",method:"GET"};for(let[n,r]of Object.entries(e))n==="id"?s.sessionIndex=r:n==="bodyBytes"?s.bodyBytes=o.transferBodyBytes(r,"ArrayBuffer"):s[n]=r;e.bodyBytes&&delete s.body,$task.fetch(s).then(n=>{let r={status:200,headers:{}};for(let[i,d]of Object.entries(n))i==="sessionIndex"?r.id=d:i==="bodyBytes"?r.bodyBytes=o.transferBodyBytes(d,"Uint8Array"):i==="statusCode"?r.status=d:r[i]=d;t(r)})})}done(e){let t=e.response??e,s={};for(let[n,r]of Object.entries(t))n==="status"?s.status=`HTTP/1.1 ${r}`:n==="bodyBytes"?s.bodyBytes=o.transferBodyBytes(r,"ArrayBuffer"):s[n]=r;$done(s)}},u=o;u.clientAdapter={id:"sessionIndex",status:"statusCode"};export{a as default};
